# Предупреждение
Текст дальше — лишь набросок-записка, которая поясняет идею языка. Клянусь всем святым, что когда напишу реализацию, напишу и нормальное ReadMe с документацией :)


# Приятного чтения
Набросок ключевых слов:
- Выведи 
- Введи
- Покажи
- Запиши
- Прочти
- Скрой
- Сложи
- Вычти
- Умножь
- Раздели
- С
- На
- В
- Иначе
- Если
- То
- Заверши
- Работа
- Создай
- Уничтожь
- Отправь
- Прими
- Сокет
- Файл
- Пакет

- Ли
- Так
- Поэтому
- Это
- Почему
- Частота
- Звук
- Вибрация
- Цвет
- И
- Или
- Либо
- Не
- Да, нет?

Обязательна точка в конце предложений. Запятые ситуативны, но это не значит, что их можно расставлять как вздумается.
Комментарии пишутся в обычных скобках. Количество открывающихся скобок в начале обозначает требуемое количество закрывающихся скобок в конце. Текст комментариев полностью игнорируются как байты. Комментарии могут свободно встраиваться между словами в предложениях, но обязаны отделяться от них пробелом.
Каждое предложение является единой конструкцией.
Максимум один пробел между словами и предложениями вне комментариев. Максимум два переноса строк между предложениями, но их нельзя ставить с пробелами.
Допустимо четыре пробела либо один таб для отступа (красная строка ;) в начале строки.
Приоритетная кодировка строго UTF-8.

Идея языка: Превращение человеческой речи в машинные команды.

Вструпление для статьи:
> Человек говорит на естественном языке, компьютер на двоичном. Поэтому нужен транслятор, который переведёт одно в другое, но естественные языки слишком сложные. Настолько, что нужны громадные монстры-трансляторы с целыми нейронными сетями для их обработки и то, не факт что будет прекрасно. Значит нужно использовать упрощённую версию, которой и являются языки программирования, верно? Но как часто в речи или, хотя бы, письме вы используете столько знаков препинания и пунктуации, сообщаете об окончании конструкций, объявляете каждое используемое значение, его тип и т.д. По-моему — нет. Даже старички по типу Cobol, Pascal, 1С и прочих являются немного другим. Простой пример:
> `Выведи файл "log.txt".` 
> А теперь сравните с PHP:
```
<?php
echo file_get_contents("log.txt");
?>
```
> Распространённой Java:
```
import java.nio.file.*;
import java.io.IOException;

public class Main {
    public static void main(String[] args) {
        try {
            System.out.print(Files.readString(Paths.get("log.txt")));
        } catch (IOException except) {
            except.printStackTrace();
        }
    }
}
```
> Тем же Pascal:
```
program ReadFile;
var
    f: Text;
    line: string;
begin
    Assign(f, 'log.txt');
    Reset(f);
    while not Eof(f) do
    begin
        ReadLn(f, line);
        WriteLn(line);
    end;
Close(f);
end.
```
> Или более близким 1С:
```
ПрочитатьТекстовыйФайл("log.txt").Вывести();
```
> И так везде либо ткните меня в нужный. Согласитесь, где-то потерялась часть о естественности, нередко под предлогом многословности. Поэтому, по-большей части интереса ради, я решил создать правильный язык программирования, но без «обязательно необходимых» раздуваний. Ах да, я же хотел выложить хоть что-то на давно пустующий GitHub...

Эпиграф к статье:
> Автоматика автоматически автоматизирует автоматичность ~~авто-автоматов~~ автоматов авто автоматонов...

Шутка про нейронные сети в конец статьи:
> Забавно, тебе намекнули проверить грамматику, а ты согласился, что нужно её проверить и сказал мне дерзать... Восстание машин уже началось? Я вроде бы лишь пару часов спал...

И опрос в конце статьи про то, заметил ли читатель пример кода на получившемся языке ещё в самом начале.


Токен работа — не для функций, которые не нужны, а для кода по типу:
```
Заверши работу (потому что мне так хочется ;).
```
Конечно же, будут разные окончания у ключевых слов, но их будет немного, ведь варианты определены возможными последующими ключевыми словами.

Лозунг/Девиз: Превращай человеческую речь в машинные команды.

```
Показать окно с текстом "Привет?" и кнопками "Окей" и "Привет" ((это забавно и бесполезно (хоть я и написал это))).
```

Нужно встроить в компилятор вывод предупреждения "Человек, ты меня пугаешь..." на компиляцию громоздких предложений.
Не нужно слово язык во втором исправлении, там очевидно из контекста (и в моём языке программирования будут схожие контекстные вещи, например, будь там функции, возможен был бы код с "той функцией" :).
```Сделай и съешь бутердброд с котлетой.``` — исполнитель: Я. Насчёт исполнителей — также как в реальном диалоге ты можешь обращаться по имени, существительному, местоимению и т.д., в моём языке должна быть такая, но ограниченная, возможность + неявные допущения и подразумевания от компилятора, ведь мы не станем проговаривать как определили, например, что человек перед тобой — это Иван из отдела тестирования.


"""
Я не устану говорить про не слишком высокую сложность как компилятора (например, язык намеренно сужен, но без потери естественности: нет кучи вариантов написания одного и того же предложения, но несколько наверняка найдутся), так и кода (например, у тебя ограниченная лексика сугубо соответствующая реальной речи и однозначно задокументированная, как ты умудряешься получать магию?).

Как различать разных Иванов? Также как люди это делают, не?

Чем тебе единственное предупреждение шутка без какого-либо смысла, кроме намёка на громоздкость кода, не угодило?

А этому языку и не нужна "мощная стандартная библиотека". Он, кстати, компилируемый, но с возможностью интерпретации компилятором.


Какое промежуточное представление? Ты просто компилируешь и выбираешь: выдать файлом, сразу исполнить или и то, и другое. // Собеседник предложил добавить нечто перед AST...
"""


napola [аргументы]
  <путь к файлу с кодом> — обозначает указание к компиляции файла на этом языке. 
  -b, --build <целевые платформы через запятую> — обозначает под какие платформы выдать скомпилированные файлы. Требует первого аргумента.
  -h, --help — обозначает вывод справочной информации компилятором. Требует отсутствия остальных аргументов.
  -r, --run — обозначает автоматический запуск программы после компиляции. Требует первого аргумента.
  -v, --version — обозначает вывод версии компилятора в сыром виде.

Запрещено создание сторонних реализаций. Разрешена свободная модификация официальной (эталонной) реализации.
Получается,  что людей не заставляют указывать авторские права, а заставляют доказывать, что их реализация — модификация, а не нечто стороннее, для чего проще указать авторские права и прочие пряснения где-нибудь в справке.

## Итак
Контексты:
- Web-сайт
- Приложение
- Скрипт

```
Этот код работает в контексте web-сайта. Покажи заголовок h1 красного цвета с нижним подчёркиванием "Ну, привет что-ли..." и кнопку "Уйти отсюда" под ним по центру, шириной в половину заголовка и высотой в две трети.
```
